{"ast":null,"code":"import _objectSpread from\"C:/Users/Rama Krishna/videolibrary-app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// src/devModeChecks/identityFunctionCheck.ts\nvar runIdentityFunctionCheck=(resultFunc,inputSelectorsResults,outputSelectorResult)=>{if(inputSelectorsResults.length===1&&inputSelectorsResults[0]===outputSelectorResult){let isInputSameAsOutput=false;try{const emptyObject={};if(resultFunc(emptyObject)===emptyObject)isInputSameAsOutput=true;}catch(_unused){}if(isInputSameAsOutput){let stack=void 0;try{throw new Error();}catch(e){;({stack}=e);}console.warn(\"The result function returned its own inputs without modification. e.g\\n`createSelector([state => state.todos], todos => todos)`\\nThis could lead to inefficient memoization and unnecessary re-renders.\\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.\",{stack});}}};// src/devModeChecks/inputStabilityCheck.ts\nvar runInputStabilityCheck=(inputSelectorResultsObject,options,inputSelectorArgs)=>{const{memoize,memoizeOptions}=options;const{inputSelectorResults,inputSelectorResultsCopy}=inputSelectorResultsObject;const createAnEmptyObject=memoize(()=>({}),...memoizeOptions);const areInputSelectorResultsEqual=createAnEmptyObject.apply(null,inputSelectorResults)===createAnEmptyObject.apply(null,inputSelectorResultsCopy);if(!areInputSelectorResultsEqual){let stack=void 0;try{throw new Error();}catch(e){;({stack}=e);}console.warn(\"An input selector returned a different result when passed same arguments.\\nThis means your output selector will likely run more frequently than intended.\\nAvoid returning a new reference inside your input selector, e.g.\\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`\",{arguments:inputSelectorArgs,firstInputs:inputSelectorResults,secondInputs:inputSelectorResultsCopy,stack});}};// src/devModeChecks/setGlobalDevModeChecks.ts\nvar globalDevModeChecks={inputStabilityCheck:\"once\",identityFunctionCheck:\"once\"};var setGlobalDevModeChecks=devModeChecks=>{Object.assign(globalDevModeChecks,devModeChecks);};// src/utils.ts\nvar NOT_FOUND=/* @__PURE__ */Symbol(\"NOT_FOUND\");function assertIsFunction(func){let errorMessage=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"expected a function, instead received \".concat(typeof func);if(typeof func!==\"function\"){throw new TypeError(errorMessage);}}function assertIsObject(object){let errorMessage=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"expected an object, instead received \".concat(typeof object);if(typeof object!==\"object\"){throw new TypeError(errorMessage);}}function assertIsArrayOfFunctions(array){let errorMessage=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"expected all items to be functions, instead received the following types: \";if(!array.every(item=>typeof item===\"function\")){const itemTypes=array.map(item=>typeof item===\"function\"?\"function \".concat(item.name||\"unnamed\",\"()\"):typeof item).join(\", \");throw new TypeError(\"\".concat(errorMessage,\"[\").concat(itemTypes,\"]\"));}}var ensureIsArray=item=>{return Array.isArray(item)?item:[item];};function getDependencies(createSelectorArgs){const dependencies=Array.isArray(createSelectorArgs[0])?createSelectorArgs[0]:createSelectorArgs;assertIsArrayOfFunctions(dependencies,\"createSelector expects all input-selectors to be functions, but received the following types: \");return dependencies;}function collectInputSelectorResults(dependencies,inputSelectorArgs){const inputSelectorResults=[];const{length}=dependencies;for(let i=0;i<length;i++){inputSelectorResults.push(dependencies[i].apply(null,inputSelectorArgs));}return inputSelectorResults;}var getDevModeChecksExecutionInfo=(firstRun,devModeChecks)=>{const{identityFunctionCheck,inputStabilityCheck}=_objectSpread(_objectSpread({},globalDevModeChecks),devModeChecks);return{identityFunctionCheck:{shouldRun:identityFunctionCheck===\"always\"||identityFunctionCheck===\"once\"&&firstRun,run:runIdentityFunctionCheck},inputStabilityCheck:{shouldRun:inputStabilityCheck===\"always\"||inputStabilityCheck===\"once\"&&firstRun,run:runInputStabilityCheck}};};// src/autotrackMemoize/autotracking.ts\nvar $REVISION=0;var CURRENT_TRACKER=null;var Cell=class Cell{constructor(initialValue){let isEqual=arguments.length>1&&arguments[1]!==undefined?arguments[1]:tripleEq;this.revision=$REVISION;this._isEqual=tripleEq;this._value=this._lastValue=initialValue;this._isEqual=isEqual;}// Whenever a storage value is read, it'll add itself to the current tracker if\n// one exists, entangling its state with that cache.\nget value(){var _CURRENT_TRACKER;(_CURRENT_TRACKER=CURRENT_TRACKER)===null||_CURRENT_TRACKER===void 0?void 0:_CURRENT_TRACKER.add(this);return this._value;}// Whenever a storage value is updated, we bump the global revision clock,\n// assign the revision for this storage to the new value, _and_ we schedule a\n// rerender. This is important, and it's what makes autotracking  _pull_\n// based. We don't actively tell the caches which depend on the storage that\n// anything has happened. Instead, we recompute the caches when needed.\nset value(newValue){if(this.value===newValue)return;this._value=newValue;this.revision=++$REVISION;}};function tripleEq(a,b){return a===b;}var TrackingCache=class TrackingCache{constructor(fn){this._cachedRevision=-1;this._deps=[];this.hits=0;this.fn=fn;}clear(){this._cachedValue=void 0;this._cachedRevision=-1;this._deps=[];this.hits=0;}get value(){var _CURRENT_TRACKER2;if(this.revision>this._cachedRevision){const{fn}=this;const currentTracker=/* @__PURE__ */new Set();const prevTracker=CURRENT_TRACKER;CURRENT_TRACKER=currentTracker;this._cachedValue=fn();CURRENT_TRACKER=prevTracker;this.hits++;this._deps=Array.from(currentTracker);this._cachedRevision=this.revision;}(_CURRENT_TRACKER2=CURRENT_TRACKER)===null||_CURRENT_TRACKER2===void 0?void 0:_CURRENT_TRACKER2.add(this);return this._cachedValue;}get revision(){return Math.max(...this._deps.map(d=>d.revision),0);}};function getValue(cell){if(!(cell instanceof Cell)){console.warn(\"Not a valid cell! \",cell);}return cell.value;}function setValue(storage,value){if(!(storage instanceof Cell)){throw new TypeError(\"setValue must be passed a tracked store created with `createStorage`.\");}storage.value=storage._lastValue=value;}function createCell(initialValue){let isEqual=arguments.length>1&&arguments[1]!==undefined?arguments[1]:tripleEq;return new Cell(initialValue,isEqual);}function createCache(fn){assertIsFunction(fn,\"the first parameter to `createCache` must be a function\");return new TrackingCache(fn);}// src/autotrackMemoize/tracking.ts\nvar neverEq=(a,b)=>false;function createTag(){return createCell(null,neverEq);}function dirtyTag(tag,value){setValue(tag,value);}var consumeCollection=node=>{let tag=node.collectionTag;if(tag===null){tag=node.collectionTag=createTag();}getValue(tag);};var dirtyCollection=node=>{const tag=node.collectionTag;if(tag!==null){dirtyTag(tag,null);}};// src/autotrackMemoize/proxy.ts\nvar REDUX_PROXY_LABEL=Symbol();var nextId=0;var proto=Object.getPrototypeOf({});var ObjectTreeNode=class ObjectTreeNode{constructor(value){this.proxy=new Proxy(this,objectProxyHandler);this.tag=createTag();this.tags={};this.children={};this.collectionTag=null;this.id=nextId++;this.value=value;this.value=value;this.tag.value=value;}};var objectProxyHandler={get(node,key){function calculateResult(){const{value}=node;const childValue=Reflect.get(value,key);if(typeof key===\"symbol\"){return childValue;}if(key in proto){return childValue;}if(typeof childValue===\"object\"&&childValue!==null){let childNode=node.children[key];if(childNode===void 0){childNode=node.children[key]=createNode(childValue);}if(childNode.tag){getValue(childNode.tag);}return childNode.proxy;}else{let tag=node.tags[key];if(tag===void 0){tag=node.tags[key]=createTag();tag.value=childValue;}getValue(tag);return childValue;}}const res=calculateResult();return res;},ownKeys(node){consumeCollection(node);return Reflect.ownKeys(node.value);},getOwnPropertyDescriptor(node,prop){return Reflect.getOwnPropertyDescriptor(node.value,prop);},has(node,prop){return Reflect.has(node.value,prop);}};var ArrayTreeNode=class ArrayTreeNode{constructor(value){this.proxy=new Proxy([this],arrayProxyHandler);this.tag=createTag();this.tags={};this.children={};this.collectionTag=null;this.id=nextId++;this.value=value;this.value=value;this.tag.value=value;}};var arrayProxyHandler={get(_ref,key){let[node]=_ref;if(key===\"length\"){consumeCollection(node);}return objectProxyHandler.get(node,key);},ownKeys(_ref2){let[node]=_ref2;return objectProxyHandler.ownKeys(node);},getOwnPropertyDescriptor(_ref3,prop){let[node]=_ref3;return objectProxyHandler.getOwnPropertyDescriptor(node,prop);},has(_ref4,prop){let[node]=_ref4;return objectProxyHandler.has(node,prop);}};function createNode(value){if(Array.isArray(value)){return new ArrayTreeNode(value);}return new ObjectTreeNode(value);}function updateNode(node,newValue){const{value,tags,children}=node;node.value=newValue;if(Array.isArray(value)&&Array.isArray(newValue)&&value.length!==newValue.length){dirtyCollection(node);}else{if(value!==newValue){let oldKeysSize=0;let newKeysSize=0;let anyKeysAdded=false;for(const _key in value){oldKeysSize++;}for(const key in newValue){newKeysSize++;if(!(key in value)){anyKeysAdded=true;break;}}const isDifferent=anyKeysAdded||oldKeysSize!==newKeysSize;if(isDifferent){dirtyCollection(node);}}}for(const key in tags){const childValue=value[key];const newChildValue=newValue[key];if(childValue!==newChildValue){dirtyCollection(node);dirtyTag(tags[key],newChildValue);}if(typeof newChildValue===\"object\"&&newChildValue!==null){delete tags[key];}}for(const key in children){const childNode=children[key];const newChildValue=newValue[key];const childValue=childNode.value;if(childValue===newChildValue){continue;}else if(typeof newChildValue===\"object\"&&newChildValue!==null){updateNode(childNode,newChildValue);}else{deleteNode(childNode);delete children[key];}}}function deleteNode(node){if(node.tag){dirtyTag(node.tag,null);}dirtyCollection(node);for(const key in node.tags){dirtyTag(node.tags[key],null);}for(const key in node.children){deleteNode(node.children[key]);}}// src/lruMemoize.ts\nfunction createSingletonCache(equals){let entry;return{get(key){if(entry&&equals(entry.key,key)){return entry.value;}return NOT_FOUND;},put(key,value){entry={key,value};},getEntries(){return entry?[entry]:[];},clear(){entry=void 0;}};}function createLruCache(maxSize,equals){let entries=[];function get(key){const cacheIndex=entries.findIndex(entry=>equals(key,entry.key));if(cacheIndex>-1){const entry=entries[cacheIndex];if(cacheIndex>0){entries.splice(cacheIndex,1);entries.unshift(entry);}return entry.value;}return NOT_FOUND;}function put(key,value){if(get(key)===NOT_FOUND){entries.unshift({key,value});if(entries.length>maxSize){entries.pop();}}}function getEntries(){return entries;}function clear(){entries=[];}return{get,put,getEntries,clear};}var referenceEqualityCheck=(a,b)=>a===b;function createCacheKeyComparator(equalityCheck){return function areArgumentsShallowlyEqual(prev,next){if(prev===null||next===null||prev.length!==next.length){return false;}const{length}=prev;for(let i=0;i<length;i++){if(!equalityCheck(prev[i],next[i])){return false;}}return true;};}function lruMemoize(func,equalityCheckOrOptions){const providedOptions=typeof equalityCheckOrOptions===\"object\"?equalityCheckOrOptions:{equalityCheck:equalityCheckOrOptions};const{equalityCheck=referenceEqualityCheck,maxSize=1,resultEqualityCheck}=providedOptions;const comparator=createCacheKeyComparator(equalityCheck);let resultsCount=0;const cache=maxSize<=1?createSingletonCache(comparator):createLruCache(maxSize,comparator);function memoized(){let value=cache.get(arguments);if(value===NOT_FOUND){value=func.apply(null,arguments);resultsCount++;if(resultEqualityCheck){const entries=cache.getEntries();const matchingEntry=entries.find(entry=>resultEqualityCheck(entry.value,value));if(matchingEntry){value=matchingEntry.value;resultsCount!==0&&resultsCount--;}}cache.put(arguments,value);}return value;}memoized.clearCache=()=>{cache.clear();memoized.resetResultsCount();};memoized.resultsCount=()=>resultsCount;memoized.resetResultsCount=()=>{resultsCount=0;};return memoized;}// src/autotrackMemoize/autotrackMemoize.ts\nfunction autotrackMemoize(func){const node=createNode([]);let lastArgs=null;const shallowEqual=createCacheKeyComparator(referenceEqualityCheck);const cache=createCache(()=>{const res=func.apply(null,node.proxy);return res;});function memoized(){if(!shallowEqual(lastArgs,arguments)){updateNode(node,arguments);lastArgs=arguments;}return cache.value;}memoized.clearCache=()=>{return cache.clear();};return memoized;}// src/weakMapMemoize.ts\nvar StrongRef=class{constructor(value){this.value=value;}deref(){return this.value;}};var Ref=typeof WeakRef!==\"undefined\"?WeakRef:StrongRef;var UNTERMINATED=0;var TERMINATED=1;function createCacheNode(){return{s:UNTERMINATED,v:void 0,o:null,p:null};}function weakMapMemoize(func){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let fnNode=createCacheNode();const{resultEqualityCheck}=options;let lastResult;let resultsCount=0;function memoized(){let cacheNode=fnNode;const{length}=arguments;for(let i=0,l=length;i<l;i++){const arg=arguments[i];if(typeof arg===\"function\"||typeof arg===\"object\"&&arg!==null){let objectCache=cacheNode.o;if(objectCache===null){cacheNode.o=objectCache=/* @__PURE__ */new WeakMap();}const objectNode=objectCache.get(arg);if(objectNode===void 0){cacheNode=createCacheNode();objectCache.set(arg,cacheNode);}else{cacheNode=objectNode;}}else{let primitiveCache=cacheNode.p;if(primitiveCache===null){cacheNode.p=primitiveCache=/* @__PURE__ */new Map();}const primitiveNode=primitiveCache.get(arg);if(primitiveNode===void 0){cacheNode=createCacheNode();primitiveCache.set(arg,cacheNode);}else{cacheNode=primitiveNode;}}}const terminatedNode=cacheNode;let result;if(cacheNode.s===TERMINATED){result=cacheNode.v;}else{result=func.apply(null,arguments);resultsCount++;if(resultEqualityCheck){var _lastResult$deref,_lastResult,_lastResult$deref2;const lastResultValue=(_lastResult$deref=(_lastResult=lastResult)===null||_lastResult===void 0?void 0:(_lastResult$deref2=_lastResult.deref)===null||_lastResult$deref2===void 0?void 0:_lastResult$deref2.call(_lastResult))!==null&&_lastResult$deref!==void 0?_lastResult$deref:lastResult;if(lastResultValue!=null&&resultEqualityCheck(lastResultValue,result)){result=lastResultValue;resultsCount!==0&&resultsCount--;}const needsWeakRef=typeof result===\"object\"&&result!==null||typeof result===\"function\";lastResult=needsWeakRef?new Ref(result):result;}}terminatedNode.s=TERMINATED;terminatedNode.v=result;return result;}memoized.clearCache=()=>{fnNode=createCacheNode();memoized.resetResultsCount();};memoized.resultsCount=()=>resultsCount;memoized.resetResultsCount=()=>{resultsCount=0;};return memoized;}// src/createSelectorCreator.ts\nfunction createSelectorCreator(memoizeOrOptions){for(var _len=arguments.length,memoizeOptionsFromArgs=new Array(_len>1?_len-1:0),_key2=1;_key2<_len;_key2++){memoizeOptionsFromArgs[_key2-1]=arguments[_key2];}const createSelectorCreatorOptions=typeof memoizeOrOptions===\"function\"?{memoize:memoizeOrOptions,memoizeOptions:memoizeOptionsFromArgs}:memoizeOrOptions;const createSelector2=function(){for(var _len2=arguments.length,createSelectorArgs=new Array(_len2),_key3=0;_key3<_len2;_key3++){createSelectorArgs[_key3]=arguments[_key3];}let recomputations=0;let dependencyRecomputations=0;let lastResult;let directlyPassedOptions={};let resultFunc=createSelectorArgs.pop();if(typeof resultFunc===\"object\"){directlyPassedOptions=resultFunc;resultFunc=createSelectorArgs.pop();}assertIsFunction(resultFunc,\"createSelector expects an output function after the inputs, but received: [\".concat(typeof resultFunc,\"]\"));const combinedOptions=_objectSpread(_objectSpread({},createSelectorCreatorOptions),directlyPassedOptions);const{memoize,memoizeOptions=[],argsMemoize=weakMapMemoize,argsMemoizeOptions=[],devModeChecks={}}=combinedOptions;const finalMemoizeOptions=ensureIsArray(memoizeOptions);const finalArgsMemoizeOptions=ensureIsArray(argsMemoizeOptions);const dependencies=getDependencies(createSelectorArgs);const memoizedResultFunc=memoize(function recomputationWrapper(){recomputations++;return resultFunc.apply(null,arguments);},...finalMemoizeOptions);let firstRun=true;const selector=argsMemoize(function dependenciesChecker(){dependencyRecomputations++;const inputSelectorResults=collectInputSelectorResults(dependencies,arguments);lastResult=memoizedResultFunc.apply(null,inputSelectorResults);if(process.env.NODE_ENV!==\"production\"){const{identityFunctionCheck,inputStabilityCheck}=getDevModeChecksExecutionInfo(firstRun,devModeChecks);if(identityFunctionCheck.shouldRun){identityFunctionCheck.run(resultFunc,inputSelectorResults,lastResult);}if(inputStabilityCheck.shouldRun){const inputSelectorResultsCopy=collectInputSelectorResults(dependencies,arguments);inputStabilityCheck.run({inputSelectorResults,inputSelectorResultsCopy},{memoize,memoizeOptions:finalMemoizeOptions},arguments);}if(firstRun)firstRun=false;}return lastResult;},...finalArgsMemoizeOptions);return Object.assign(selector,{resultFunc,memoizedResultFunc,dependencies,dependencyRecomputations:()=>dependencyRecomputations,resetDependencyRecomputations:()=>{dependencyRecomputations=0;},lastResult:()=>lastResult,recomputations:()=>recomputations,resetRecomputations:()=>{recomputations=0;},memoize,argsMemoize});};Object.assign(createSelector2,{withTypes:()=>createSelector2});return createSelector2;}var createSelector=/* @__PURE__ */createSelectorCreator(weakMapMemoize);// src/createStructuredSelector.ts\nvar createStructuredSelector=Object.assign(function(inputSelectorsObject){let selectorCreator=arguments.length>1&&arguments[1]!==undefined?arguments[1]:createSelector;assertIsObject(inputSelectorsObject,\"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a \".concat(typeof inputSelectorsObject));const inputSelectorKeys=Object.keys(inputSelectorsObject);const dependencies=inputSelectorKeys.map(key=>inputSelectorsObject[key]);const structuredSelector=selectorCreator(dependencies,function(){for(var _len3=arguments.length,inputSelectorResults=new Array(_len3),_key4=0;_key4<_len3;_key4++){inputSelectorResults[_key4]=arguments[_key4];}return inputSelectorResults.reduce((composition,value,index)=>{composition[inputSelectorKeys[index]]=value;return composition;},{});});return structuredSelector;},{withTypes:()=>createStructuredSelector});export{createSelector,createSelectorCreator,createStructuredSelector,lruMemoize,referenceEqualityCheck,setGlobalDevModeChecks,autotrackMemoize as unstable_autotrackMemoize,weakMapMemoize};","map":{"version":3,"names":["runIdentityFunctionCheck","resultFunc","inputSelectorsResults","outputSelectorResult","length","isInputSameAsOutput","emptyObject","_unused","stack","Error","e","console","warn","runInputStabilityCheck","inputSelectorResultsObject","options","inputSelectorArgs","memoize","memoizeOptions","inputSelectorResults","inputSelectorResultsCopy","createAnEmptyObject","areInputSelectorResultsEqual","apply","arguments","firstInputs","secondInputs","globalDevModeChecks","inputStabilityCheck","identityFunctionCheck","setGlobalDevModeChecks","devModeChecks","Object","assign","NOT_FOUND","Symbol","assertIsFunction","func","errorMessage","undefined","concat","TypeError","assertIsObject","object","assertIsArrayOfFunctions","array","every","item","itemTypes","map","name","join","ensureIsArray","Array","isArray","getDependencies","createSelectorArgs","dependencies","collectInputSelectorResults","i","push","getDevModeChecksExecutionInfo","firstRun","_objectSpread","shouldRun","run","$REVISION","CURRENT_TRACKER","Cell","constructor","initialValue","isEqual","tripleEq","revision","_isEqual","_value","_lastValue","value","_CURRENT_TRACKER","add","newValue","a","b","TrackingCache","fn","_cachedRevision","_deps","hits","clear","_cachedValue","_CURRENT_TRACKER2","currentTracker","Set","prevTracker","from","Math","max","d","getValue","cell","setValue","storage","createCell","createCache","neverEq","createTag","dirtyTag","tag","consumeCollection","node","collectionTag","dirtyCollection","REDUX_PROXY_LABEL","nextId","proto","getPrototypeOf","ObjectTreeNode","proxy","Proxy","objectProxyHandler","tags","children","id","get","key","calculateResult","childValue","Reflect","childNode","createNode","res","ownKeys","getOwnPropertyDescriptor","prop","has","ArrayTreeNode","arrayProxyHandler","_ref","_ref2","_ref3","_ref4","updateNode","oldKeysSize","newKeysSize","anyKeysAdded","_key","isDifferent","newChildValue","deleteNode","createSingletonCache","equals","entry","put","getEntries","createLruCache","maxSize","entries","cacheIndex","findIndex","splice","unshift","pop","referenceEqualityCheck","createCacheKeyComparator","equalityCheck","areArgumentsShallowlyEqual","prev","next","lruMemoize","equalityCheckOrOptions","providedOptions","resultEqualityCheck","comparator","resultsCount","cache","memoized","matchingEntry","find","clearCache","resetResultsCount","autotrackMemoize","lastArgs","shallowEqual","StrongRef","deref","Ref","WeakRef","UNTERMINATED","TERMINATED","createCacheNode","s","v","o","p","weakMapMemoize","fnNode","lastResult","cacheNode","l","arg","objectCache","WeakMap","objectNode","set","primitiveCache","Map","primitiveNode","terminatedNode","result","_lastResult$deref","_lastResult","_lastResult$deref2","lastResultValue","call","needsWeakRef","createSelectorCreator","memoizeOrOptions","_len","memoizeOptionsFromArgs","_key2","createSelectorCreatorOptions","createSelector2","createSelector","_len2","_key3","recomputations","dependencyRecomputations","directlyPassedOptions","combinedOptions","argsMemoize","argsMemoizeOptions","finalMemoizeOptions","finalArgsMemoizeOptions","memoizedResultFunc","recomputationWrapper","selector","dependenciesChecker","process","env","NODE_ENV","resetDependencyRecomputations","resetRecomputations","withTypes","createStructuredSelector","inputSelectorsObject","selectorCreator","inputSelectorKeys","keys","structuredSelector","_len3","_key4","reduce","composition","index"],"sources":["C:\\Users\\Rama Krishna\\videolibrary-app\\frontend\\src\\node_modules\\reselect\\src\\devModeChecks\\identityFunctionCheck.ts","C:\\Users\\Rama Krishna\\videolibrary-app\\frontend\\src\\node_modules\\reselect\\src\\devModeChecks\\inputStabilityCheck.ts","C:\\Users\\Rama Krishna\\videolibrary-app\\frontend\\src\\node_modules\\reselect\\src\\devModeChecks\\setGlobalDevModeChecks.ts","C:\\Users\\Rama Krishna\\videolibrary-app\\frontend\\src\\node_modules\\reselect\\src\\utils.ts","C:\\Users\\Rama Krishna\\videolibrary-app\\frontend\\src\\node_modules\\reselect\\src\\autotrackMemoize\\autotracking.ts","C:\\Users\\Rama Krishna\\videolibrary-app\\frontend\\src\\node_modules\\reselect\\src\\autotrackMemoize\\tracking.ts","C:\\Users\\Rama Krishna\\videolibrary-app\\frontend\\src\\node_modules\\reselect\\src\\autotrackMemoize\\proxy.ts","C:\\Users\\Rama Krishna\\videolibrary-app\\frontend\\src\\node_modules\\reselect\\src\\lruMemoize.ts","C:\\Users\\Rama Krishna\\videolibrary-app\\frontend\\src\\node_modules\\reselect\\src\\autotrackMemoize\\autotrackMemoize.ts","C:\\Users\\Rama Krishna\\videolibrary-app\\frontend\\src\\node_modules\\reselect\\src\\weakMapMemoize.ts","C:\\Users\\Rama Krishna\\videolibrary-app\\frontend\\src\\node_modules\\reselect\\src\\createSelectorCreator.ts","C:\\Users\\Rama Krishna\\videolibrary-app\\frontend\\src\\node_modules\\reselect\\src\\createStructuredSelector.ts"],"sourcesContent":["import type { AnyFunction } from '../types'\r\n\r\n/**\r\n * Runs a check to determine if the given result function behaves as an\r\n * identity function. An identity function is one that returns its\r\n * input unchanged, for example, `x => x`. This check helps ensure\r\n * efficient memoization and prevent unnecessary re-renders by encouraging\r\n * proper use of transformation logic in result functions and\r\n * extraction logic in input selectors.\r\n *\r\n * @param resultFunc - The result function to be checked.\r\n * @param inputSelectorsResults - The results of the input selectors.\r\n * @param outputSelectorResult - The result of the output selector.\r\n *\r\n * @see {@link https://reselect.js.org/api/development-only-stability-checks#identityfunctioncheck `identityFunctionCheck`}\r\n *\r\n * @since 5.0.0\r\n * @internal\r\n */\r\nexport const runIdentityFunctionCheck = (\r\n  resultFunc: AnyFunction,\r\n  inputSelectorsResults: unknown[],\r\n  outputSelectorResult: unknown\r\n) => {\r\n  if (\r\n    inputSelectorsResults.length === 1 &&\r\n    inputSelectorsResults[0] === outputSelectorResult\r\n  ) {\r\n    let isInputSameAsOutput = false\r\n    try {\r\n      const emptyObject = {}\r\n      if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true\r\n    } catch {\r\n      // Do nothing\r\n    }\r\n    if (isInputSameAsOutput) {\r\n      let stack: string | undefined = undefined\r\n      try {\r\n        throw new Error()\r\n      } catch (e) {\r\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi, no-extra-semi\r\n        ;({ stack } = e as Error)\r\n      }\r\n      console.warn(\r\n        'The result function returned its own inputs without modification. e.g' +\r\n          '\\n`createSelector([state => state.todos], todos => todos)`' +\r\n          '\\nThis could lead to inefficient memoization and unnecessary re-renders.' +\r\n          '\\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.',\r\n        { stack }\r\n      )\r\n    }\r\n  }\r\n}\r\n","import type { CreateSelectorOptions, UnknownMemoizer } from '../types'\r\n\r\n/**\r\n * Runs a stability check to ensure the input selector results remain stable\r\n * when provided with the same arguments. This function is designed to detect\r\n * changes in the output of input selectors, which can impact the performance of memoized selectors.\r\n *\r\n * @param inputSelectorResultsObject - An object containing two arrays: `inputSelectorResults` and `inputSelectorResultsCopy`, representing the results of input selectors.\r\n * @param options - Options object consisting of a `memoize` function and a `memoizeOptions` object.\r\n * @param inputSelectorArgs - List of arguments being passed to the input selectors.\r\n *\r\n * @see {@link https://reselect.js.org/api/development-only-stability-checks/#inputstabilitycheck `inputStabilityCheck`}\r\n *\r\n * @since 5.0.0\r\n * @internal\r\n */\r\nexport const runInputStabilityCheck = (\r\n  inputSelectorResultsObject: {\r\n    inputSelectorResults: unknown[]\r\n    inputSelectorResultsCopy: unknown[]\r\n  },\r\n  options: Required<\r\n    Pick<\r\n      CreateSelectorOptions<UnknownMemoizer, UnknownMemoizer>,\r\n      'memoize' | 'memoizeOptions'\r\n    >\r\n  >,\r\n  inputSelectorArgs: unknown[] | IArguments\r\n) => {\r\n  const { memoize, memoizeOptions } = options\r\n  const { inputSelectorResults, inputSelectorResultsCopy } =\r\n    inputSelectorResultsObject\r\n  const createAnEmptyObject = memoize(() => ({}), ...memoizeOptions)\r\n  // if the memoize method thinks the parameters are equal, these *should* be the same reference\r\n  const areInputSelectorResultsEqual =\r\n    createAnEmptyObject.apply(null, inputSelectorResults) ===\r\n    createAnEmptyObject.apply(null, inputSelectorResultsCopy)\r\n  if (!areInputSelectorResultsEqual) {\r\n    let stack: string | undefined = undefined\r\n    try {\r\n      throw new Error()\r\n    } catch (e) {\r\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi, no-extra-semi\r\n      ;({ stack } = e as Error)\r\n    }\r\n    console.warn(\r\n      'An input selector returned a different result when passed same arguments.' +\r\n        '\\nThis means your output selector will likely run more frequently than intended.' +\r\n        '\\nAvoid returning a new reference inside your input selector, e.g.' +\r\n        '\\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`',\r\n      {\r\n        arguments: inputSelectorArgs,\r\n        firstInputs: inputSelectorResults,\r\n        secondInputs: inputSelectorResultsCopy,\r\n        stack\r\n      }\r\n    )\r\n  }\r\n}\r\n","import type { DevModeChecks } from '../types'\r\n\r\n/**\r\n * Global configuration for development mode checks. This specifies the default\r\n * frequency at which each development mode check should be performed.\r\n *\r\n * @since 5.0.0\r\n * @internal\r\n */\r\nexport const globalDevModeChecks: DevModeChecks = {\r\n  inputStabilityCheck: 'once',\r\n  identityFunctionCheck: 'once'\r\n}\r\n\r\n/**\r\n * Overrides the development mode checks settings for all selectors.\r\n *\r\n * Reselect performs additional checks in development mode to help identify and\r\n * warn about potential issues in selector behavior. This function allows you to\r\n * customize the behavior of these checks across all selectors in your application.\r\n *\r\n * **Note**: This setting can still be overridden per selector inside `createSelector`'s `options` object.\r\n * See {@link https://github.com/reduxjs/reselect#2-per-selector-by-passing-an-identityfunctioncheck-option-directly-to-createselector per-selector-configuration}\r\n * and {@linkcode CreateSelectorOptions.identityFunctionCheck identityFunctionCheck} for more details.\r\n *\r\n * _The development mode checks do not run in production builds._\r\n *\r\n * @param devModeChecks - An object specifying the desired settings for development mode checks. You can provide partial overrides. Unspecified settings will retain their current values.\r\n *\r\n * @example\r\n * ```ts\r\n * import { setGlobalDevModeChecks } from 'reselect'\r\n * import { DevModeChecks } from '../types'\r\n *\r\n * // Run only the first time the selector is called. (default)\r\n * setGlobalDevModeChecks({ inputStabilityCheck: 'once' })\r\n *\r\n * // Run every time the selector is called.\r\n * setGlobalDevModeChecks({ inputStabilityCheck: 'always' })\r\n *\r\n * // Never run the input stability check.\r\n * setGlobalDevModeChecks({ inputStabilityCheck: 'never' })\r\n *\r\n * // Run only the first time the selector is called. (default)\r\n * setGlobalDevModeChecks({ identityFunctionCheck: 'once' })\r\n *\r\n * // Run every time the selector is called.\r\n * setGlobalDevModeChecks({ identityFunctionCheck: 'always' })\r\n *\r\n * // Never run the identity function check.\r\n * setGlobalDevModeChecks({ identityFunctionCheck: 'never' })\r\n * ```\r\n * @see {@link https://reselect.js.org/api/development-only-stability-checks Development-Only Stability Checks}\r\n * @see {@link https://reselect.js.org/api/development-only-stability-checks#1-globally-through-setglobaldevmodechecks global-configuration}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport const setGlobalDevModeChecks = (\r\n  devModeChecks: Partial<DevModeChecks>\r\n) => {\r\n  Object.assign(globalDevModeChecks, devModeChecks)\r\n}\r\n","import { runIdentityFunctionCheck } from './devModeChecks/identityFunctionCheck'\r\nimport { runInputStabilityCheck } from './devModeChecks/inputStabilityCheck'\r\nimport { globalDevModeChecks } from './devModeChecks/setGlobalDevModeChecks'\r\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\r\nimport type {\r\n  DevModeChecks,\r\n  Selector,\r\n  SelectorArray,\r\n  DevModeChecksExecutionInfo\r\n} from './types'\r\n\r\nexport const NOT_FOUND = /* @__PURE__ */ Symbol('NOT_FOUND')\r\nexport type NOT_FOUND_TYPE = typeof NOT_FOUND\r\n\r\n/**\r\n * Assert that the provided value is a function. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param func - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsFunction<FunctionType extends Function>(\r\n  func: unknown,\r\n  errorMessage = `expected a function, instead received ${typeof func}`\r\n): asserts func is FunctionType {\r\n  if (typeof func !== 'function') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided value is an object. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param object - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsObject<ObjectType extends Record<string, unknown>>(\r\n  object: unknown,\r\n  errorMessage = `expected an object, instead received ${typeof object}`\r\n): asserts object is ObjectType {\r\n  if (typeof object !== 'object') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided array is an array of functions. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param array - The array to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsArrayOfFunctions<FunctionType extends Function>(\r\n  array: unknown[],\r\n  errorMessage = `expected all items to be functions, instead received the following types: `\r\n): asserts array is FunctionType[] {\r\n  if (\r\n    !array.every((item): item is FunctionType => typeof item === 'function')\r\n  ) {\r\n    const itemTypes = array\r\n      .map(item =>\r\n        typeof item === 'function'\r\n          ? `function ${item.name || 'unnamed'}()`\r\n          : typeof item\r\n      )\r\n      .join(', ')\r\n    throw new TypeError(`${errorMessage}[${itemTypes}]`)\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure that the input is an array. If it's already an array, it's returned as is.\r\n * If it's not an array, it will be wrapped in a new array.\r\n *\r\n * @param item - The item to be checked.\r\n * @returns An array containing the input item. If the input is already an array, it's returned without modification.\r\n */\r\nexport const ensureIsArray = (item: unknown) => {\r\n  return Array.isArray(item) ? item : [item]\r\n}\r\n\r\n/**\r\n * Extracts the \"dependencies\" / \"input selectors\" from the arguments of `createSelector`.\r\n *\r\n * @param createSelectorArgs - Arguments passed to `createSelector` as an array.\r\n * @returns An array of \"input selectors\" / \"dependencies\".\r\n * @throws A `TypeError` if any of the input selectors is not function.\r\n */\r\nexport function getDependencies(createSelectorArgs: unknown[]) {\r\n  const dependencies = Array.isArray(createSelectorArgs[0])\r\n    ? createSelectorArgs[0]\r\n    : createSelectorArgs\r\n\r\n  assertIsArrayOfFunctions<Selector>(\r\n    dependencies,\r\n    `createSelector expects all input-selectors to be functions, but received the following types: `\r\n  )\r\n\r\n  return dependencies as SelectorArray\r\n}\r\n\r\n/**\r\n * Runs each input selector and returns their collective results as an array.\r\n *\r\n * @param dependencies - An array of \"dependencies\" or \"input selectors\".\r\n * @param inputSelectorArgs - An array of arguments being passed to the input selectors.\r\n * @returns An array of input selector results.\r\n */\r\nexport function collectInputSelectorResults(\r\n  dependencies: SelectorArray,\r\n  inputSelectorArgs: unknown[] | IArguments\r\n) {\r\n  const inputSelectorResults = []\r\n  const { length } = dependencies\r\n  for (let i = 0; i < length; i++) {\r\n    // @ts-ignore\r\n    // apply arguments instead of spreading and mutate a local list of params for performance.\r\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs))\r\n  }\r\n  return inputSelectorResults\r\n}\r\n\r\n/**\r\n * Retrieves execution information for development mode checks.\r\n *\r\n * @param devModeChecks - Custom Settings for development mode checks. These settings will override the global defaults.\r\n * @param firstRun - Indicates whether it is the first time the selector has run.\r\n * @returns  An object containing the execution information for each development mode check.\r\n */\r\nexport const getDevModeChecksExecutionInfo = (\r\n  firstRun: boolean,\r\n  devModeChecks: Partial<DevModeChecks>\r\n) => {\r\n  const { identityFunctionCheck, inputStabilityCheck } = {\r\n    ...globalDevModeChecks,\r\n    ...devModeChecks\r\n  }\r\n  return {\r\n    identityFunctionCheck: {\r\n      shouldRun:\r\n        identityFunctionCheck === 'always' ||\r\n        (identityFunctionCheck === 'once' && firstRun),\r\n      run: runIdentityFunctionCheck\r\n    },\r\n    inputStabilityCheck: {\r\n      shouldRun:\r\n        inputStabilityCheck === 'always' ||\r\n        (inputStabilityCheck === 'once' && firstRun),\r\n      run: runInputStabilityCheck\r\n    }\r\n  } satisfies DevModeChecksExecutionInfo\r\n}\r\n","// Original autotracking implementation source:\r\n// - https://gist.github.com/pzuraq/79bf862e0f8cd9521b79c4b6eccdc4f9\r\n// Additional references:\r\n// - https://www.pzuraq.com/blog/how-autotracking-works\r\n// - https://v5.chriskrycho.com/journal/autotracking-elegant-dx-via-cutting-edge-cs/\r\nimport type { EqualityFn } from '../types'\r\nimport { assertIsFunction } from '../utils'\r\n\r\n// The global revision clock. Every time state changes, the clock increments.\r\nexport let $REVISION = 0\r\n\r\n// The current dependency tracker. Whenever we compute a cache, we create a Set\r\n// to track any dependencies that are used while computing. If no cache is\r\n// computing, then the tracker is null.\r\nlet CURRENT_TRACKER: Set<Cell<any> | TrackingCache> | null = null\r\n\r\n// Storage represents a root value in the system - the actual state of our app.\r\nexport class Cell<T> {\r\n  revision = $REVISION\r\n\r\n  _value: T\r\n  _lastValue: T\r\n  _isEqual: EqualityFn = tripleEq\r\n\r\n  constructor(initialValue: T, isEqual: EqualityFn = tripleEq) {\r\n    this._value = this._lastValue = initialValue\r\n    this._isEqual = isEqual\r\n  }\r\n\r\n  // Whenever a storage value is read, it'll add itself to the current tracker if\r\n  // one exists, entangling its state with that cache.\r\n  get value() {\r\n    CURRENT_TRACKER?.add(this)\r\n\r\n    return this._value\r\n  }\r\n\r\n  // Whenever a storage value is updated, we bump the global revision clock,\r\n  // assign the revision for this storage to the new value, _and_ we schedule a\r\n  // rerender. This is important, and it's what makes autotracking  _pull_\r\n  // based. We don't actively tell the caches which depend on the storage that\r\n  // anything has happened. Instead, we recompute the caches when needed.\r\n  set value(newValue) {\r\n    if (this.value === newValue) return\r\n\r\n    this._value = newValue\r\n    this.revision = ++$REVISION\r\n  }\r\n}\r\n\r\nfunction tripleEq(a: unknown, b: unknown) {\r\n  return a === b\r\n}\r\n\r\n// Caches represent derived state in the system. They are ultimately functions\r\n// that are memoized based on what state they use to produce their output,\r\n// meaning they will only rerun IFF a storage value that could affect the output\r\n// has changed. Otherwise, they'll return the cached value.\r\nexport class TrackingCache {\r\n  _cachedValue: any\r\n  _cachedRevision = -1\r\n  _deps: any[] = []\r\n  hits = 0\r\n\r\n  fn: () => any\r\n\r\n  constructor(fn: () => any) {\r\n    this.fn = fn\r\n  }\r\n\r\n  clear() {\r\n    this._cachedValue = undefined\r\n    this._cachedRevision = -1\r\n    this._deps = []\r\n    this.hits = 0\r\n  }\r\n\r\n  get value() {\r\n    // When getting the value for a Cache, first we check all the dependencies of\r\n    // the cache to see what their current revision is. If the current revision is\r\n    // greater than the cached revision, then something has changed.\r\n    if (this.revision > this._cachedRevision) {\r\n      const { fn } = this\r\n\r\n      // We create a new dependency tracker for this cache. As the cache runs\r\n      // its function, any Storage or Cache instances which are used while\r\n      // computing will be added to this tracker. In the end, it will be the\r\n      // full list of dependencies that this Cache depends on.\r\n      const currentTracker = new Set<Cell<any>>()\r\n      const prevTracker = CURRENT_TRACKER\r\n\r\n      CURRENT_TRACKER = currentTracker\r\n\r\n      // try {\r\n      this._cachedValue = fn()\r\n      // } finally {\r\n      CURRENT_TRACKER = prevTracker\r\n      this.hits++\r\n      this._deps = Array.from(currentTracker)\r\n\r\n      // Set the cached revision. This is the current clock count of all the\r\n      // dependencies. If any dependency changes, this number will be less\r\n      // than the new revision.\r\n      this._cachedRevision = this.revision\r\n      // }\r\n    }\r\n\r\n    // If there is a current tracker, it means another Cache is computing and\r\n    // using this one, so we add this one to the tracker.\r\n    CURRENT_TRACKER?.add(this)\r\n\r\n    // Always return the cached value.\r\n    return this._cachedValue\r\n  }\r\n\r\n  get revision() {\r\n    // The current revision is the max of all the dependencies' revisions.\r\n    return Math.max(...this._deps.map(d => d.revision), 0)\r\n  }\r\n}\r\n\r\nexport function getValue<T>(cell: Cell<T>): T {\r\n  if (!(cell instanceof Cell)) {\r\n    console.warn('Not a valid cell! ', cell)\r\n  }\r\n\r\n  return cell.value\r\n}\r\n\r\ntype CellValue<T extends Cell<unknown>> = T extends Cell<infer U> ? U : never\r\n\r\nexport function setValue<T extends Cell<unknown>>(\r\n  storage: T,\r\n  value: CellValue<T>\r\n): void {\r\n  if (!(storage instanceof Cell)) {\r\n    throw new TypeError(\r\n      'setValue must be passed a tracked store created with `createStorage`.'\r\n    )\r\n  }\r\n\r\n  storage.value = storage._lastValue = value\r\n}\r\n\r\nexport function createCell<T = unknown>(\r\n  initialValue: T,\r\n  isEqual: EqualityFn = tripleEq\r\n): Cell<T> {\r\n  return new Cell(initialValue, isEqual)\r\n}\r\n\r\nexport function createCache<T = unknown>(fn: () => T): TrackingCache {\r\n  assertIsFunction(\r\n    fn,\r\n    'the first parameter to `createCache` must be a function'\r\n  )\r\n\r\n  return new TrackingCache(fn)\r\n}\r\n","import type { Cell } from './autotracking'\r\nimport {\r\n  getValue as consumeTag,\r\n  createCell as createStorage,\r\n  setValue\r\n} from './autotracking'\r\n\r\nexport type Tag = Cell<unknown>\r\n\r\nconst neverEq = (a: any, b: any): boolean => false\r\n\r\nexport function createTag(): Tag {\r\n  return createStorage(null, neverEq)\r\n}\r\nexport { consumeTag }\r\nexport function dirtyTag(tag: Tag, value: any): void {\r\n  setValue(tag, value)\r\n}\r\n\r\nexport interface Node<\r\n  T extends Array<unknown> | Record<string, unknown> =\r\n    | Array<unknown>\r\n    | Record<string, unknown>\r\n> {\r\n  collectionTag: Tag | null\r\n  tag: Tag | null\r\n  tags: Record<string, Tag>\r\n  children: Record<string, Node>\r\n  proxy: T\r\n  value: T\r\n  id: number\r\n}\r\n\r\nexport const consumeCollection = (node: Node): void => {\r\n  let tag = node.collectionTag\r\n\r\n  if (tag === null) {\r\n    tag = node.collectionTag = createTag()\r\n  }\r\n\r\n  consumeTag(tag)\r\n}\r\n\r\nexport const dirtyCollection = (node: Node): void => {\r\n  const tag = node.collectionTag\r\n\r\n  if (tag !== null) {\r\n    dirtyTag(tag, null)\r\n  }\r\n}\r\n","// Original source:\r\n// - https://github.com/simonihmig/tracked-redux/blob/master/packages/tracked-redux/src/-private/proxy.ts\r\n\r\nimport type { Node, Tag } from './tracking'\r\nimport {\r\n  consumeCollection,\r\n  consumeTag,\r\n  createTag,\r\n  dirtyCollection,\r\n  dirtyTag\r\n} from './tracking'\r\n\r\nexport const REDUX_PROXY_LABEL = Symbol()\r\n\r\nlet nextId = 0\r\n\r\nconst proto = Object.getPrototypeOf({})\r\n\r\nclass ObjectTreeNode<T extends Record<string, unknown>> implements Node<T> {\r\n  proxy: T = new Proxy(this, objectProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {} as Record<string, Tag>\r\n  children = {} as Record<string, Node>\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst objectProxyHandler = {\r\n  get(node: Node, key: string | symbol): unknown {\r\n    function calculateResult() {\r\n      const { value } = node\r\n\r\n      const childValue = Reflect.get(value, key)\r\n\r\n      if (typeof key === 'symbol') {\r\n        return childValue\r\n      }\r\n\r\n      if (key in proto) {\r\n        return childValue\r\n      }\r\n\r\n      if (typeof childValue === 'object' && childValue !== null) {\r\n        let childNode = node.children[key]\r\n\r\n        if (childNode === undefined) {\r\n          childNode = node.children[key] = createNode(childValue)\r\n        }\r\n\r\n        if (childNode.tag) {\r\n          consumeTag(childNode.tag)\r\n        }\r\n\r\n        return childNode.proxy\r\n      } else {\r\n        let tag = node.tags[key]\r\n\r\n        if (tag === undefined) {\r\n          tag = node.tags[key] = createTag()\r\n          tag.value = childValue\r\n        }\r\n\r\n        consumeTag(tag)\r\n\r\n        return childValue\r\n      }\r\n    }\r\n    const res = calculateResult()\r\n    return res\r\n  },\r\n\r\n  ownKeys(node: Node): ArrayLike<string | symbol> {\r\n    consumeCollection(node)\r\n    return Reflect.ownKeys(node.value)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    node: Node,\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return Reflect.getOwnPropertyDescriptor(node.value, prop)\r\n  },\r\n\r\n  has(node: Node, prop: string | symbol): boolean {\r\n    return Reflect.has(node.value, prop)\r\n  }\r\n}\r\n\r\nclass ArrayTreeNode<T extends Array<unknown>> implements Node<T> {\r\n  proxy: T = new Proxy([this], arrayProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {}\r\n  children = {}\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst arrayProxyHandler = {\r\n  get([node]: [Node], key: string | symbol): unknown {\r\n    if (key === 'length') {\r\n      consumeCollection(node)\r\n    }\r\n\r\n    return objectProxyHandler.get(node, key)\r\n  },\r\n\r\n  ownKeys([node]: [Node]): ArrayLike<string | symbol> {\r\n    return objectProxyHandler.ownKeys(node)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    [node]: [Node],\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop)\r\n  },\r\n\r\n  has([node]: [Node], prop: string | symbol): boolean {\r\n    return objectProxyHandler.has(node, prop)\r\n  }\r\n}\r\n\r\nexport function createNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  value: T\r\n): Node<T> {\r\n  if (Array.isArray(value)) {\r\n    return new ArrayTreeNode(value)\r\n  }\r\n\r\n  return new ObjectTreeNode(value) as Node<T>\r\n}\r\n\r\nconst keysMap = new WeakMap<\r\n  Array<unknown> | Record<string, unknown>,\r\n  Set<string>\r\n>()\r\n\r\nexport function updateNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  node: Node<T>,\r\n  newValue: T\r\n): void {\r\n  const { value, tags, children } = node\r\n\r\n  node.value = newValue\r\n\r\n  if (\r\n    Array.isArray(value) &&\r\n    Array.isArray(newValue) &&\r\n    value.length !== newValue.length\r\n  ) {\r\n    dirtyCollection(node)\r\n  } else {\r\n    if (value !== newValue) {\r\n      let oldKeysSize = 0\r\n      let newKeysSize = 0\r\n      let anyKeysAdded = false\r\n\r\n      for (const _key in value) {\r\n        oldKeysSize++\r\n      }\r\n\r\n      for (const key in newValue) {\r\n        newKeysSize++\r\n        if (!(key in value)) {\r\n          anyKeysAdded = true\r\n          break\r\n        }\r\n      }\r\n\r\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize\r\n\r\n      if (isDifferent) {\r\n        dirtyCollection(node)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const key in tags) {\r\n    const childValue = (value as Record<string, unknown>)[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    if (childValue !== newChildValue) {\r\n      dirtyCollection(node)\r\n      dirtyTag(tags[key], newChildValue)\r\n    }\r\n\r\n    if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      delete tags[key]\r\n    }\r\n  }\r\n\r\n  for (const key in children) {\r\n    const childNode = children[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    const childValue = childNode.value\r\n\r\n    if (childValue === newChildValue) {\r\n      continue\r\n    } else if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      updateNode(childNode, newChildValue as Record<string, unknown>)\r\n    } else {\r\n      deleteNode(childNode)\r\n      delete children[key]\r\n    }\r\n  }\r\n}\r\n\r\nfunction deleteNode(node: Node): void {\r\n  if (node.tag) {\r\n    dirtyTag(node.tag, null)\r\n  }\r\n  dirtyCollection(node)\r\n  for (const key in node.tags) {\r\n    dirtyTag(node.tags[key], null)\r\n  }\r\n  for (const key in node.children) {\r\n    deleteNode(node.children[key])\r\n  }\r\n}\r\n","import type {\r\n  AnyFunction,\r\n  DefaultMemoizeFields,\r\n  EqualityFn,\r\n  Simplify\r\n} from './types'\r\n\r\nimport type { NOT_FOUND_TYPE } from './utils'\r\nimport { NOT_FOUND } from './utils'\r\n\r\n// Cache implementation based on Erik Rasmussen's `lru-memoize`:\r\n// https://github.com/erikras/lru-memoize\r\n\r\ninterface Entry {\r\n  key: unknown\r\n  value: unknown\r\n}\r\n\r\ninterface Cache {\r\n  get(key: unknown): unknown | NOT_FOUND_TYPE\r\n  put(key: unknown, value: unknown): void\r\n  getEntries(): Entry[]\r\n  clear(): void\r\n}\r\n\r\nfunction createSingletonCache(equals: EqualityFn): Cache {\r\n  let entry: Entry | undefined\r\n  return {\r\n    get(key: unknown) {\r\n      if (entry && equals(entry.key, key)) {\r\n        return entry.value\r\n      }\r\n\r\n      return NOT_FOUND\r\n    },\r\n\r\n    put(key: unknown, value: unknown) {\r\n      entry = { key, value }\r\n    },\r\n\r\n    getEntries() {\r\n      return entry ? [entry] : []\r\n    },\r\n\r\n    clear() {\r\n      entry = undefined\r\n    }\r\n  }\r\n}\r\n\r\nfunction createLruCache(maxSize: number, equals: EqualityFn): Cache {\r\n  let entries: Entry[] = []\r\n\r\n  function get(key: unknown) {\r\n    const cacheIndex = entries.findIndex(entry => equals(key, entry.key))\r\n\r\n    // We found a cached entry\r\n    if (cacheIndex > -1) {\r\n      const entry = entries[cacheIndex]\r\n\r\n      // Cached entry not at top of cache, move it to the top\r\n      if (cacheIndex > 0) {\r\n        entries.splice(cacheIndex, 1)\r\n        entries.unshift(entry)\r\n      }\r\n\r\n      return entry.value\r\n    }\r\n\r\n    // No entry found in cache, return sentinel\r\n    return NOT_FOUND\r\n  }\r\n\r\n  function put(key: unknown, value: unknown) {\r\n    if (get(key) === NOT_FOUND) {\r\n      // TODO Is unshift slow?\r\n      entries.unshift({ key, value })\r\n      if (entries.length > maxSize) {\r\n        entries.pop()\r\n      }\r\n    }\r\n  }\r\n\r\n  function getEntries() {\r\n    return entries\r\n  }\r\n\r\n  function clear() {\r\n    entries = []\r\n  }\r\n\r\n  return { get, put, getEntries, clear }\r\n}\r\n\r\n/**\r\n * Runs a simple reference equality check.\r\n * What {@linkcode lruMemoize lruMemoize} uses by default.\r\n *\r\n * **Note**: This function was previously known as `defaultEqualityCheck`.\r\n *\r\n * @public\r\n */\r\nexport const referenceEqualityCheck: EqualityFn = (a, b) => a === b\r\n\r\nexport function createCacheKeyComparator(equalityCheck: EqualityFn) {\r\n  return function areArgumentsShallowlyEqual(\r\n    prev: unknown[] | IArguments | null,\r\n    next: unknown[] | IArguments | null\r\n  ): boolean {\r\n    if (prev === null || next === null || prev.length !== next.length) {\r\n      return false\r\n    }\r\n\r\n    // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\r\n    const { length } = prev\r\n    for (let i = 0; i < length; i++) {\r\n      if (!equalityCheck(prev[i], next[i])) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\n/**\r\n * Options for configuring the behavior of a function memoized with\r\n * LRU (Least Recently Used) caching.\r\n *\r\n * @template Result - The type of the return value of the memoized function.\r\n *\r\n * @public\r\n */\r\nexport interface LruMemoizeOptions<Result = any> {\r\n  /**\r\n   * Function used to compare the individual arguments of the\r\n   * provided calculation function.\r\n   *\r\n   * @default referenceEqualityCheck\r\n   */\r\n  equalityCheck?: EqualityFn\r\n\r\n  /**\r\n   * If provided, used to compare a newly generated output value against\r\n   * previous values in the cache. If a match is found,\r\n   * the old value is returned. This addresses the common\r\n   * ```ts\r\n   * todos.map(todo => todo.id)\r\n   * ```\r\n   * use case, where an update to another field in the original data causes\r\n   * a recalculation due to changed references, but the output is still\r\n   * effectively the same.\r\n   *\r\n   * @since 4.1.0\r\n   */\r\n  resultEqualityCheck?: EqualityFn<Result>\r\n\r\n  /**\r\n   * The maximum size of the cache used by the selector.\r\n   * A size greater than 1 means the selector will use an\r\n   * LRU (Least Recently Used) cache, allowing for the caching of multiple\r\n   * results based on different sets of arguments.\r\n   *\r\n   * @default 1\r\n   */\r\n  maxSize?: number\r\n}\r\n\r\n/**\r\n * Creates a memoized version of a function with an optional\r\n * LRU (Least Recently Used) cache. The memoized function uses a cache to\r\n * store computed values. Depending on the `maxSize` option, it will use\r\n * either a singleton cache (for a single entry) or an\r\n * LRU cache (for multiple entries).\r\n *\r\n * **Note**: This function was previously known as `defaultMemoize`.\r\n *\r\n * @param func - The function to be memoized.\r\n * @param equalityCheckOrOptions - Either an equality check function or an options object.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/lruMemoize `lruMemoize`}\r\n *\r\n * @public\r\n */\r\nexport function lruMemoize<Func extends AnyFunction>(\r\n  func: Func,\r\n  equalityCheckOrOptions?: EqualityFn | LruMemoizeOptions<ReturnType<Func>>\r\n) {\r\n  const providedOptions =\r\n    typeof equalityCheckOrOptions === 'object'\r\n      ? equalityCheckOrOptions\r\n      : { equalityCheck: equalityCheckOrOptions }\r\n\r\n  const {\r\n    equalityCheck = referenceEqualityCheck,\r\n    maxSize = 1,\r\n    resultEqualityCheck\r\n  } = providedOptions\r\n\r\n  const comparator = createCacheKeyComparator(equalityCheck)\r\n\r\n  let resultsCount = 0\r\n\r\n  const cache =\r\n    maxSize <= 1\r\n      ? createSingletonCache(comparator)\r\n      : createLruCache(maxSize, comparator)\r\n\r\n  function memoized() {\r\n    let value = cache.get(arguments) as ReturnType<Func>\r\n    if (value === NOT_FOUND) {\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      value = func.apply(null, arguments) as ReturnType<Func>\r\n      resultsCount++\r\n\r\n      if (resultEqualityCheck) {\r\n        const entries = cache.getEntries()\r\n        const matchingEntry = entries.find(entry =>\r\n          resultEqualityCheck(entry.value as ReturnType<Func>, value)\r\n        )\r\n\r\n        if (matchingEntry) {\r\n          value = matchingEntry.value as ReturnType<Func>\r\n          resultsCount !== 0 && resultsCount--\r\n        }\r\n      }\r\n\r\n      cache.put(arguments, value)\r\n    }\r\n    return value\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    cache.clear()\r\n    memoized.resetResultsCount()\r\n  }\r\n\r\n  memoized.resultsCount = () => resultsCount\r\n\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","import { createNode, updateNode } from './proxy'\r\nimport type { Node } from './tracking'\r\n\r\nimport { createCacheKeyComparator, referenceEqualityCheck } from '../lruMemoize'\r\nimport type { AnyFunction, DefaultMemoizeFields, Simplify } from '../types'\r\nimport { createCache } from './autotracking'\r\n\r\n/**\r\n * Uses an \"auto-tracking\" approach inspired by the work of the Ember Glimmer team.\r\n * It uses a Proxy to wrap arguments and track accesses to nested fields\r\n * in your selector on first read. Later, when the selector is called with\r\n * new arguments, it identifies which accessed fields have changed and\r\n * only recalculates the result if one or more of those accessed fields have changed.\r\n * This allows it to be more precise than the shallow equality checks in `lruMemoize`.\r\n *\r\n * __Design Tradeoffs for `autotrackMemoize`:__\r\n * - Pros:\r\n *    - It is likely to avoid excess calculations and recalculate fewer times than `lruMemoize` will,\r\n *    which may also result in fewer component re-renders.\r\n * - Cons:\r\n *    - It only has a cache size of 1.\r\n *    - It is slower than `lruMemoize`, because it has to do more work. (How much slower is dependent on the number of accessed fields in a selector, number of calls, frequency of input changes, etc)\r\n *    - It can have some unexpected behavior. Because it tracks nested field accesses,\r\n *    cases where you don't access a field will not recalculate properly.\r\n *    For example, a badly-written selector like:\r\n *      ```ts\r\n *      createSelector([state => state.todos], todos => todos)\r\n *      ```\r\n *      that just immediately returns the extracted value will never update, because it doesn't see any field accesses to check.\r\n *\r\n * __Use Cases for `autotrackMemoize`:__\r\n * - It is likely best used for cases where you need to access specific nested fields\r\n * in data, and avoid recalculating if other fields in the same data objects are immutably updated.\r\n *\r\n * @param func - The function to be memoized.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @example\r\n * <caption>Using `createSelector`</caption>\r\n * ```ts\r\n * import { unstable_autotrackMemoize as autotrackMemoize, createSelector } from 'reselect'\r\n *\r\n * const selectTodoIds = createSelector(\r\n *   [(state: RootState) => state.todos],\r\n *   (todos) => todos.map(todo => todo.id),\r\n *   { memoize: autotrackMemoize }\r\n * )\r\n * ```\r\n *\r\n * @example\r\n * <caption>Using `createSelectorCreator`</caption>\r\n * ```ts\r\n * import { unstable_autotrackMemoize as autotrackMemoize, createSelectorCreator } from 'reselect'\r\n *\r\n * const createSelectorAutotrack = createSelectorCreator({ memoize: autotrackMemoize })\r\n *\r\n * const selectTodoIds = createSelectorAutotrack(\r\n *   [(state: RootState) => state.todos],\r\n *   (todos) => todos.map(todo => todo.id)\r\n * )\r\n * ```\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/unstable_autotrackMemoize autotrackMemoize}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n * @experimental\r\n */\r\nexport function autotrackMemoize<Func extends AnyFunction>(func: Func) {\r\n  // we reference arguments instead of spreading them for performance reasons\r\n\r\n  const node: Node<Record<string, unknown>> = createNode(\r\n    [] as unknown as Record<string, unknown>\r\n  )\r\n\r\n  let lastArgs: IArguments | null = null\r\n\r\n  const shallowEqual = createCacheKeyComparator(referenceEqualityCheck)\r\n\r\n  const cache = createCache(() => {\r\n    const res = func.apply(null, node.proxy as unknown as any[])\r\n    return res\r\n  })\r\n\r\n  function memoized() {\r\n    if (!shallowEqual(lastArgs, arguments)) {\r\n      updateNode(node, arguments as unknown as Record<string, unknown>)\r\n      lastArgs = arguments\r\n    }\r\n    return cache.value\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    return cache.clear()\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","// Original source:\r\n// - https://github.com/facebook/react/blob/0b974418c9a56f6c560298560265dcf4b65784bc/packages/react/src/ReactCache.js\r\n\r\nimport type {\r\n  AnyFunction,\r\n  DefaultMemoizeFields,\r\n  EqualityFn,\r\n  Simplify\r\n} from './types'\r\n\r\nclass StrongRef<T> {\r\n  constructor(private value: T) {}\r\n  deref() {\r\n    return this.value\r\n  }\r\n}\r\n\r\nconst Ref =\r\n  typeof WeakRef !== 'undefined'\r\n    ? WeakRef\r\n    : (StrongRef as unknown as typeof WeakRef)\r\n\r\nconst UNTERMINATED = 0\r\nconst TERMINATED = 1\r\n\r\ninterface UnterminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 0\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: void\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular Map where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ninterface TerminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 1\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: T\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular `Map` where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ntype CacheNode<T> = TerminatedCacheNode<T> | UnterminatedCacheNode<T>\r\n\r\nfunction createCacheNode<T>(): CacheNode<T> {\r\n  return {\r\n    s: UNTERMINATED,\r\n    v: undefined,\r\n    o: null,\r\n    p: null\r\n  }\r\n}\r\n\r\n/**\r\n * Configuration options for a memoization function utilizing `WeakMap` for\r\n * its caching mechanism.\r\n *\r\n * @template Result - The type of the return value of the memoized function.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport interface WeakMapMemoizeOptions<Result = any> {\r\n  /**\r\n   * If provided, used to compare a newly generated output value against previous values in the cache.\r\n   * If a match is found, the old value is returned. This addresses the common\r\n   * ```ts\r\n   * todos.map(todo => todo.id)\r\n   * ```\r\n   * use case, where an update to another field in the original data causes a recalculation\r\n   * due to changed references, but the output is still effectively the same.\r\n   *\r\n   * @since 5.0.0\r\n   */\r\n  resultEqualityCheck?: EqualityFn<Result>\r\n}\r\n\r\n/**\r\n * Creates a tree of `WeakMap`-based cache nodes based on the identity of the\r\n * arguments it's been called with (in this case, the extracted values from your input selectors).\r\n * This allows `weakMapMemoize` to have an effectively infinite cache size.\r\n * Cache results will be kept in memory as long as references to the arguments still exist,\r\n * and then cleared out as the arguments are garbage-collected.\r\n *\r\n * __Design Tradeoffs for `weakMapMemoize`:__\r\n * - Pros:\r\n *   - It has an effectively infinite cache size, but you have no control over\r\n *   how long values are kept in cache as it's based on garbage collection and `WeakMap`s.\r\n * - Cons:\r\n *   - There's currently no way to alter the argument comparisons.\r\n *   They're based on strict reference equality.\r\n *   - It's roughly the same speed as `lruMemoize`, although likely a fraction slower.\r\n *\r\n * __Use Cases for `weakMapMemoize`:__\r\n * - This memoizer is likely best used for cases where you need to call the\r\n * same selector instance with many different arguments, such as a single\r\n * selector instance that is used in a list item component and called with\r\n * item IDs like:\r\n *   ```ts\r\n *   useSelector(state => selectSomeData(state, props.category))\r\n *   ```\r\n * @param func - The function to be memoized.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @example\r\n * <caption>Using `createSelector`</caption>\r\n * ```ts\r\n * import { createSelector, weakMapMemoize } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   items: { id: number; category: string; name: string }[]\r\n * }\r\n *\r\n * const selectItemsByCategory = createSelector(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category),\r\n *   {\r\n *     memoize: weakMapMemoize,\r\n *     argsMemoize: weakMapMemoize\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @example\r\n * <caption>Using `createSelectorCreator`</caption>\r\n * ```ts\r\n * import { createSelectorCreator, weakMapMemoize } from 'reselect'\r\n *\r\n * const createSelectorWeakMap = createSelectorCreator({ memoize: weakMapMemoize, argsMemoize: weakMapMemoize })\r\n *\r\n * const selectItemsByCategory = createSelectorWeakMap(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category)\r\n * )\r\n * ```\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/weakMapMemoize `weakMapMemoize`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n * @experimental\r\n */\r\nexport function weakMapMemoize<Func extends AnyFunction>(\r\n  func: Func,\r\n  options: WeakMapMemoizeOptions<ReturnType<Func>> = {}\r\n) {\r\n  let fnNode = createCacheNode()\r\n  const { resultEqualityCheck } = options\r\n\r\n  let lastResult: WeakRef<object> | undefined\r\n\r\n  let resultsCount = 0\r\n\r\n  function memoized() {\r\n    let cacheNode = fnNode\r\n    const { length } = arguments\r\n    for (let i = 0, l = length; i < l; i++) {\r\n      const arg = arguments[i]\r\n      if (\r\n        typeof arg === 'function' ||\r\n        (typeof arg === 'object' && arg !== null)\r\n      ) {\r\n        // Objects go into a WeakMap\r\n        let objectCache = cacheNode.o\r\n        if (objectCache === null) {\r\n          cacheNode.o = objectCache = new WeakMap()\r\n        }\r\n        const objectNode = objectCache.get(arg)\r\n        if (objectNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          objectCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = objectNode\r\n        }\r\n      } else {\r\n        // Primitives go into a regular Map\r\n        let primitiveCache = cacheNode.p\r\n        if (primitiveCache === null) {\r\n          cacheNode.p = primitiveCache = new Map()\r\n        }\r\n        const primitiveNode = primitiveCache.get(arg)\r\n        if (primitiveNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          primitiveCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = primitiveNode\r\n        }\r\n      }\r\n    }\r\n\r\n    const terminatedNode = cacheNode as unknown as TerminatedCacheNode<any>\r\n\r\n    let result\r\n\r\n    if (cacheNode.s === TERMINATED) {\r\n      result = cacheNode.v\r\n    } else {\r\n      // Allow errors to propagate\r\n      result = func.apply(null, arguments as unknown as any[])\r\n      resultsCount++\r\n\r\n      if (resultEqualityCheck) {\r\n        const lastResultValue = lastResult?.deref?.() ?? lastResult\r\n\r\n        if (\r\n          lastResultValue != null &&\r\n          resultEqualityCheck(lastResultValue as ReturnType<Func>, result)\r\n        ) {\r\n          result = lastResultValue\r\n\r\n          resultsCount !== 0 && resultsCount--\r\n        }\r\n\r\n        const needsWeakRef =\r\n          (typeof result === 'object' && result !== null) ||\r\n          typeof result === 'function'\r\n\r\n        lastResult = needsWeakRef ? new Ref(result) : result\r\n      }\r\n    }\r\n\r\n    terminatedNode.s = TERMINATED\r\n\r\n    terminatedNode.v = result\r\n    return result\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    fnNode = createCacheNode()\r\n    memoized.resetResultsCount()\r\n  }\r\n\r\n  memoized.resultsCount = () => resultsCount\r\n\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","import { weakMapMemoize } from './weakMapMemoize'\r\n\r\nimport type {\r\n  Combiner,\r\n  CreateSelectorOptions,\r\n  DropFirstParameter,\r\n  ExtractMemoizerFields,\r\n  GetParamsFromSelectors,\r\n  GetStateFromSelectors,\r\n  InterruptRecursion,\r\n  OutputSelector,\r\n  Selector,\r\n  SelectorArray,\r\n  SetRequired,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\n\r\nimport {\r\n  assertIsFunction,\r\n  collectInputSelectorResults,\r\n  ensureIsArray,\r\n  getDependencies,\r\n  getDevModeChecksExecutionInfo\r\n} from './utils'\r\n\r\n/**\r\n * An instance of `createSelector`, customized with a given memoize implementation.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n * @template StateType - The type of state that the selectors created with this selector creator will operate on.\r\n *\r\n * @public\r\n */\r\nexport interface CreateSelectorFunction<\r\n  MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  StateType = any\r\n> {\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments and a `combiner` function.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <InputSelectors extends SelectorArray<StateType>, Result>(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments, a `combiner` function and an `options` object.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray<StateType>,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions: Simplify<\r\n        CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n      >\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param inputSelectors - An array of input selectors.\r\n   * @param combiner - A function that Combines the input selectors and returns an output selector. Otherwise known as the result function.\r\n   * @param createSelectorOptions - An optional options object that allows for further customization per selector.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray<StateType>,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    inputSelectors: [...InputSelectors],\r\n    combiner: Combiner<InputSelectors, Result>,\r\n    createSelectorOptions?: Simplify<\r\n      CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    >\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a \"pre-typed\" version of {@linkcode createSelector createSelector}\r\n   * where the `state` type is predefined.\r\n   *\r\n   * This allows you to set the `state` type once, eliminating the need to\r\n   * specify it with every {@linkcode createSelector createSelector} call.\r\n   *\r\n   * @returns A pre-typed `createSelector` with the state type already defined.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * import { createSelector } from 'reselect'\r\n   *\r\n   * export interface RootState {\r\n   *   todos: { id: number; completed: boolean }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * export const createAppSelector = createSelector.withTypes<RootState>()\r\n   *\r\n   * const selectTodoIds = createAppSelector(\r\n   *   [\r\n   *     // Type of `state` is set to `RootState`, no need to manually set the type\r\n   *     state => state.todos\r\n   *   ],\r\n   *   todos => todos.map(({ id }) => id)\r\n   * )\r\n   * ```\r\n   * @template OverrideStateType - The specific type of state used by all selectors created with this selector creator.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector#defining-a-pre-typed-createselector `createSelector.withTypes`}\r\n   *\r\n   * @since 5.1.0\r\n   */\r\n  withTypes: <OverrideStateType extends StateType>() => CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction,\r\n    OverrideStateType\r\n  >\r\n}\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param options - An options object containing the `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). It also provides additional options for customizing memoization. While the `memoize` property is mandatory, the rest are optional.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator({\r\n *   memoize: customMemoize, // Function to be used to memoize `resultFunc`\r\n *   memoizeOptions: [memoizeOption1, memoizeOption2], // Options passed to `customMemoize` as the second argument onwards\r\n *   argsMemoize: customArgsMemoize, // Function to be used to memoize the selector's arguments\r\n *   argsMemoizeOptions: [argsMemoizeOption1, argsMemoizeOption2] // Options passed to `customArgsMemoize` as the second argument onwards\r\n * })\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n *\r\n * customSelector(\r\n *   ...selectorArgs // Will be memoized by `customArgsMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-options-since-500 `createSelectorCreator`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n>(\r\n  options: Simplify<\r\n    SetRequired<\r\n      CreateSelectorOptions<\r\n        typeof weakMapMemoize,\r\n        typeof weakMapMemoize,\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      >,\r\n      'memoize'\r\n    >\r\n  >\r\n): CreateSelectorFunction<MemoizeFunction, ArgsMemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param memoize - The `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator(customMemoize, // Function to be used to memoize `resultFunc`\r\n *   option1, // Will be passed as second argument to `customMemoize`\r\n *   option2, // Will be passed as third argument to `customMemoize`\r\n *   option3 // Will be passed as fourth argument to `customMemoize`\r\n * )\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-memoize-and-memoizeoptions `createSelectorCreator`}\r\n *\r\n * @public\r\n */\r\nexport function createSelectorCreator<MemoizeFunction extends UnknownMemoizer>(\r\n  memoize: MemoizeFunction,\r\n  ...memoizeOptionsFromArgs: DropFirstParameter<MemoizeFunction>\r\n): CreateSelectorFunction<MemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization\r\n * function and options for customizing memoization behavior.\r\n *\r\n * @param memoizeOrOptions - Either A `memoize` function or an `options` object containing the `memoize` function.\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n * @template MemoizeOrOptions - The type of the first argument. It can either be a `memoize` function or an `options` object containing the `memoize` function.\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer,\r\n  MemoizeOrOptions extends\r\n    | MemoizeFunction\r\n    | SetRequired<\r\n        CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n        'memoize'\r\n      >\r\n>(\r\n  memoizeOrOptions: MemoizeOrOptions,\r\n  ...memoizeOptionsFromArgs: MemoizeOrOptions extends SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  >\r\n    ? never\r\n    : DropFirstParameter<MemoizeFunction>\r\n) {\r\n  /** options initially passed into `createSelectorCreator`. */\r\n  const createSelectorCreatorOptions: SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  > = typeof memoizeOrOptions === 'function'\r\n    ? {\r\n        memoize: memoizeOrOptions as MemoizeFunction,\r\n        memoizeOptions: memoizeOptionsFromArgs\r\n      }\r\n    : memoizeOrOptions\r\n\r\n  const createSelector = <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: [...InputSelectors],\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions?: CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    ]\r\n  ) => {\r\n    let recomputations = 0\r\n    let dependencyRecomputations = 0\r\n    let lastResult: Result\r\n\r\n    // Due to the intricacies of rest params, we can't do an optional arg after `...createSelectorArgs`.\r\n    // So, start by declaring the default value here.\r\n    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\r\n    let directlyPassedOptions: CreateSelectorOptions<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    > = {}\r\n\r\n    // Normally, the result func or \"combiner\" is the last arg\r\n    let resultFunc = createSelectorArgs.pop() as\r\n      | Combiner<InputSelectors, Result>\r\n      | CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n\r\n    // If the result func is actually an _object_, assume it's our options object\r\n    if (typeof resultFunc === 'object') {\r\n      directlyPassedOptions = resultFunc\r\n      // and pop the real result func off\r\n      resultFunc = createSelectorArgs.pop() as Combiner<InputSelectors, Result>\r\n    }\r\n\r\n    assertIsFunction(\r\n      resultFunc,\r\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\r\n    )\r\n\r\n    // Determine which set of options we're using. Prefer options passed directly,\r\n    // but fall back to options given to `createSelectorCreator`.\r\n    const combinedOptions = {\r\n      ...createSelectorCreatorOptions,\r\n      ...directlyPassedOptions\r\n    }\r\n\r\n    const {\r\n      memoize,\r\n      memoizeOptions = [],\r\n      argsMemoize = weakMapMemoize,\r\n      argsMemoizeOptions = [],\r\n      devModeChecks = {}\r\n    } = combinedOptions\r\n\r\n    // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\r\n    // is an array. In most libs I've looked at, it's an equality function or options object.\r\n    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\r\n    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\r\n    // we wrap it in an array so we can apply it.\r\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions)\r\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions)\r\n    const dependencies = getDependencies(createSelectorArgs) as InputSelectors\r\n\r\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\r\n      recomputations++\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      return (resultFunc as Combiner<InputSelectors, Result>).apply(\r\n        null,\r\n        arguments as unknown as Parameters<Combiner<InputSelectors, Result>>\r\n      )\r\n    }, ...finalMemoizeOptions) as Combiner<InputSelectors, Result> &\r\n      ExtractMemoizerFields<OverrideMemoizeFunction>\r\n\r\n    let firstRun = true\r\n\r\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\r\n    const selector = argsMemoize(function dependenciesChecker() {\r\n      dependencyRecomputations++\r\n      /** Return values of input selectors which the `resultFunc` takes as arguments. */\r\n      const inputSelectorResults = collectInputSelectorResults(\r\n        dependencies,\r\n        arguments\r\n      )\r\n\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults)\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        const { identityFunctionCheck, inputStabilityCheck } =\r\n          getDevModeChecksExecutionInfo(firstRun, devModeChecks)\r\n        if (identityFunctionCheck.shouldRun) {\r\n          identityFunctionCheck.run(\r\n            resultFunc as Combiner<InputSelectors, Result>,\r\n            inputSelectorResults,\r\n            lastResult\r\n          )\r\n        }\r\n\r\n        if (inputStabilityCheck.shouldRun) {\r\n          // make a second copy of the params, to check if we got the same results\r\n          const inputSelectorResultsCopy = collectInputSelectorResults(\r\n            dependencies,\r\n            arguments\r\n          )\r\n\r\n          inputStabilityCheck.run(\r\n            { inputSelectorResults, inputSelectorResultsCopy },\r\n            { memoize, memoizeOptions: finalMemoizeOptions },\r\n            arguments\r\n          )\r\n        }\r\n\r\n        if (firstRun) firstRun = false\r\n      }\r\n\r\n      return lastResult\r\n    }, ...finalArgsMemoizeOptions) as unknown as Selector<\r\n      GetStateFromSelectors<InputSelectors>,\r\n      Result,\r\n      GetParamsFromSelectors<InputSelectors>\r\n    > &\r\n      ExtractMemoizerFields<OverrideArgsMemoizeFunction>\r\n\r\n    return Object.assign(selector, {\r\n      resultFunc,\r\n      memoizedResultFunc,\r\n      dependencies,\r\n      dependencyRecomputations: () => dependencyRecomputations,\r\n      resetDependencyRecomputations: () => {\r\n        dependencyRecomputations = 0\r\n      },\r\n      lastResult: () => lastResult,\r\n      recomputations: () => recomputations,\r\n      resetRecomputations: () => {\r\n        recomputations = 0\r\n      },\r\n      memoize,\r\n      argsMemoize\r\n    }) as OutputSelector<\r\n      InputSelectors,\r\n      Result,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    >\r\n  }\r\n\r\n  Object.assign(createSelector, {\r\n    withTypes: () => createSelector\r\n  })\r\n\r\n  return createSelector as CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  >\r\n}\r\n\r\n/**\r\n * Accepts one or more \"input selectors\" (either as separate arguments or a single array),\r\n * a single \"result function\" / \"combiner\", and an optional options object, and\r\n * generates a memoized selector function.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelector `createSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createSelector =\r\n  /* #__PURE__ */ createSelectorCreator(weakMapMemoize)\r\n","import { createSelector } from './createSelectorCreator'\r\n\r\nimport type { CreateSelectorFunction } from './createSelectorCreator'\r\nimport type {\r\n  InterruptRecursion,\r\n  ObjectValuesToTuple,\r\n  OutputSelector,\r\n  Selector,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\nimport { assertIsObject } from './utils'\r\nimport type { weakMapMemoize } from './weakMapMemoize'\r\n\r\n/**\r\n * Represents a mapping of selectors to their return types.\r\n *\r\n * @template TObject - An object type where each property is a selector function.\r\n *\r\n * @public\r\n */\r\nexport type SelectorResultsMap<TObject extends SelectorsObject> = {\r\n  [Key in keyof TObject]: ReturnType<TObject[Key]>\r\n}\r\n\r\n/**\r\n * Represents a mapping of selectors for each key in a given root state.\r\n *\r\n * This type is a utility that takes a root state object type and\r\n * generates a corresponding set of selectors. Each selector is associated\r\n * with a key in the root state, allowing for the selection\r\n * of specific parts of the state.\r\n *\r\n * @template RootState - The type of the root state object.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport type RootStateSelectors<RootState = any> = {\r\n  [Key in keyof RootState]: Selector<RootState, RootState[Key], []>\r\n}\r\n\r\n/**\r\n * @deprecated Please use {@linkcode StructuredSelectorCreator.withTypes createStructuredSelector.withTypes<RootState>()} instead. This type will be removed in the future.\r\n * @template RootState - The type of the root state object.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport type TypedStructuredSelectorCreator<RootState = any> =\r\n  /**\r\n   * A convenience function that simplifies returning an object\r\n   * made up of selector results.\r\n   *\r\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n   * @returns A memoized structured selector.\r\n   *\r\n   * @example\r\n   * <caption>Modern Use Case</caption>\r\n   * ```ts\r\n   * import { createSelector, createStructuredSelector } from 'reselect'\r\n   *\r\n   * interface RootState {\r\n   *   todos: {\r\n   *     id: number\r\n   *     completed: boolean\r\n   *     title: string\r\n   *     description: string\r\n   *   }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * // This:\r\n   * const structuredSelector = createStructuredSelector(\r\n   *   {\r\n   *     todos: (state: RootState) => state.todos,\r\n   *     alerts: (state: RootState) => state.alerts,\r\n   *     todoById: (state: RootState, id: number) => state.todos[id]\r\n   *   },\r\n   *   createSelector\r\n   * )\r\n   *\r\n   * // Is essentially the same as this:\r\n   * const selector = createSelector(\r\n   *   [\r\n   *     (state: RootState) => state.todos,\r\n   *     (state: RootState) => state.alerts,\r\n   *     (state: RootState, id: number) => state.todos[id]\r\n   *   ],\r\n   *   (todos, alerts, todoById) => {\r\n   *     return {\r\n   *       todos,\r\n   *       alerts,\r\n   *       todoById\r\n   *     }\r\n   *   }\r\n   * )\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>In your component:</caption>\r\n   * ```tsx\r\n   * import type { RootState } from 'createStructuredSelector/modernUseCase'\r\n   * import { structuredSelector } from 'createStructuredSelector/modernUseCase'\r\n   * import type { FC } from 'react'\r\n   * import { useSelector } from 'react-redux'\r\n   *\r\n   * interface Props {\r\n   *   id: number\r\n   * }\r\n   *\r\n   * const MyComponent: FC<Props> = ({ id }) => {\r\n   *   const { todos, alerts, todoById } = useSelector((state: RootState) =>\r\n   *     structuredSelector(state, id)\r\n   *   )\r\n   *\r\n   *   return (\r\n   *     <div>\r\n   *       Next to do is:\r\n   *       <h2>{todoById.title}</h2>\r\n   *       <p>Description: {todoById.description}</p>\r\n   *       <ul>\r\n   *         <h3>All other to dos:</h3>\r\n   *         {todos.map(todo => (\r\n   *           <li key={todo.id}>{todo.title}</li>\r\n   *         ))}\r\n   *       </ul>\r\n   *     </div>\r\n   *   )\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>Simple Use Case</caption>\r\n   * ```ts\r\n   * const selectA = state => state.a\r\n   * const selectB = state => state.b\r\n   *\r\n   * // The result function in the following selector\r\n   * // is simply building an object from the input selectors\r\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\r\n   *   a,\r\n   *   b\r\n   * }))\r\n   *\r\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\r\n   * ```\r\n   *\r\n   * @template InputSelectorsObject - The shape of the input selectors object.\r\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\r\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n   */\r\n  <\r\n    InputSelectorsObject extends RootStateSelectors<RootState> = RootStateSelectors<RootState>,\r\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n  >(\r\n    inputSelectorsObject: InputSelectorsObject,\r\n    selectorCreator?: CreateSelectorFunction<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction\r\n    >\r\n  ) => OutputSelector<\r\n    ObjectValuesToTuple<InputSelectorsObject>,\r\n    Simplify<SelectorResultsMap<InputSelectorsObject>>,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n/**\r\n * Represents an object where each property is a selector function.\r\n *\r\n * @template StateType - The type of state that all the selectors operate on.\r\n *\r\n * @public\r\n */\r\nexport type SelectorsObject<StateType = any> = Record<\r\n  string,\r\n  Selector<StateType>\r\n>\r\n\r\n/**\r\n * It provides a way to create structured selectors.\r\n * The structured selector can take multiple input selectors\r\n * and map their output to an object with specific keys.\r\n *\r\n * @template StateType - The type of state that the structured selectors created with this structured selector creator will operate on.\r\n *\r\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n *\r\n * @public\r\n */\r\nexport interface StructuredSelectorCreator<StateType = any> {\r\n  /**\r\n   * A convenience function that simplifies returning an object\r\n   * made up of selector results.\r\n   *\r\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n   * @returns A memoized structured selector.\r\n   *\r\n   * @example\r\n   * <caption>Modern Use Case</caption>\r\n   * ```ts\r\n   * import { createSelector, createStructuredSelector } from 'reselect'\r\n   *\r\n   * interface RootState {\r\n   *   todos: {\r\n   *     id: number\r\n   *     completed: boolean\r\n   *     title: string\r\n   *     description: string\r\n   *   }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * // This:\r\n   * const structuredSelector = createStructuredSelector(\r\n   *   {\r\n   *     todos: (state: RootState) => state.todos,\r\n   *     alerts: (state: RootState) => state.alerts,\r\n   *     todoById: (state: RootState, id: number) => state.todos[id]\r\n   *   },\r\n   *   createSelector\r\n   * )\r\n   *\r\n   * // Is essentially the same as this:\r\n   * const selector = createSelector(\r\n   *   [\r\n   *     (state: RootState) => state.todos,\r\n   *     (state: RootState) => state.alerts,\r\n   *     (state: RootState, id: number) => state.todos[id]\r\n   *   ],\r\n   *   (todos, alerts, todoById) => {\r\n   *     return {\r\n   *       todos,\r\n   *       alerts,\r\n   *       todoById\r\n   *     }\r\n   *   }\r\n   * )\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>In your component:</caption>\r\n   * ```tsx\r\n   * import type { RootState } from 'createStructuredSelector/modernUseCase'\r\n   * import { structuredSelector } from 'createStructuredSelector/modernUseCase'\r\n   * import type { FC } from 'react'\r\n   * import { useSelector } from 'react-redux'\r\n   *\r\n   * interface Props {\r\n   *   id: number\r\n   * }\r\n   *\r\n   * const MyComponent: FC<Props> = ({ id }) => {\r\n   *   const { todos, alerts, todoById } = useSelector((state: RootState) =>\r\n   *     structuredSelector(state, id)\r\n   *   )\r\n   *\r\n   *   return (\r\n   *     <div>\r\n   *       Next to do is:\r\n   *       <h2>{todoById.title}</h2>\r\n   *       <p>Description: {todoById.description}</p>\r\n   *       <ul>\r\n   *         <h3>All other to dos:</h3>\r\n   *         {todos.map(todo => (\r\n   *           <li key={todo.id}>{todo.title}</li>\r\n   *         ))}\r\n   *       </ul>\r\n   *     </div>\r\n   *   )\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>Simple Use Case</caption>\r\n   * ```ts\r\n   * const selectA = state => state.a\r\n   * const selectB = state => state.b\r\n   *\r\n   * // The result function in the following selector\r\n   * // is simply building an object from the input selectors\r\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\r\n   *   a,\r\n   *   b\r\n   * }))\r\n   *\r\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\r\n   * ```\r\n   *\r\n   * @template InputSelectorsObject - The shape of the input selectors object.\r\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\r\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n   */\r\n  <\r\n    InputSelectorsObject extends SelectorsObject<StateType>,\r\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n  >(\r\n    inputSelectorsObject: InputSelectorsObject,\r\n    selectorCreator?: CreateSelectorFunction<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction\r\n    >\r\n  ): OutputSelector<\r\n    ObjectValuesToTuple<InputSelectorsObject>,\r\n    Simplify<SelectorResultsMap<InputSelectorsObject>>,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a \"pre-typed\" version of\r\n   * {@linkcode createStructuredSelector createStructuredSelector}\r\n   * where the `state` type is predefined.\r\n   *\r\n   * This allows you to set the `state` type once, eliminating the need to\r\n   * specify it with every\r\n   * {@linkcode createStructuredSelector createStructuredSelector} call.\r\n   *\r\n   * @returns A pre-typed `createStructuredSelector` with the state type already defined.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * import { createStructuredSelector } from 'reselect'\r\n   *\r\n   * export interface RootState {\r\n   *   todos: { id: number; completed: boolean }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * export const createStructuredAppSelector =\r\n   *   createStructuredSelector.withTypes<RootState>()\r\n   *\r\n   * const structuredAppSelector = createStructuredAppSelector({\r\n   *   // Type of `state` is set to `RootState`, no need to manually set the type\r\n   *   todos: state => state.todos,\r\n   *   alerts: state => state.alerts,\r\n   *   todoById: (state, id: number) => state.todos[id]\r\n   * })\r\n   *\r\n   * ```\r\n   * @template OverrideStateType - The specific type of state used by all structured selectors created with this structured selector creator.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createstructuredselector#defining-a-pre-typed-createstructuredselector `createSelector.withTypes`}\r\n   *\r\n   * @since 5.1.0\r\n   */\r\n  withTypes: <\r\n    OverrideStateType extends StateType\r\n  >() => StructuredSelectorCreator<OverrideStateType>\r\n}\r\n\r\n/**\r\n * A convenience function that simplifies returning an object\r\n * made up of selector results.\r\n *\r\n * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n * @returns A memoized structured selector.\r\n *\r\n * @example\r\n * <caption>Modern Use Case</caption>\r\n * ```ts\r\n * import { createSelector, createStructuredSelector } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   todos: {\r\n *     id: number\r\n *     completed: boolean\r\n *     title: string\r\n *     description: string\r\n *   }[]\r\n *   alerts: { id: number; read: boolean }[]\r\n * }\r\n *\r\n * // This:\r\n * const structuredSelector = createStructuredSelector(\r\n *   {\r\n *     todos: (state: RootState) => state.todos,\r\n *     alerts: (state: RootState) => state.alerts,\r\n *     todoById: (state: RootState, id: number) => state.todos[id]\r\n *   },\r\n *   createSelector\r\n * )\r\n *\r\n * // Is essentially the same as this:\r\n * const selector = createSelector(\r\n *   [\r\n *     (state: RootState) => state.todos,\r\n *     (state: RootState) => state.alerts,\r\n *     (state: RootState, id: number) => state.todos[id]\r\n *   ],\r\n *   (todos, alerts, todoById) => {\r\n *     return {\r\n *       todos,\r\n *       alerts,\r\n *       todoById\r\n *     }\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createStructuredSelector: StructuredSelectorCreator =\r\n  Object.assign(\r\n    <\r\n      InputSelectorsObject extends SelectorsObject,\r\n      MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n      ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n    >(\r\n      inputSelectorsObject: InputSelectorsObject,\r\n      selectorCreator: CreateSelectorFunction<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      > = createSelector as CreateSelectorFunction<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      >\r\n    ) => {\r\n      assertIsObject(\r\n        inputSelectorsObject,\r\n        'createStructuredSelector expects first argument to be an object ' +\r\n          `where each property is a selector, instead received a ${typeof inputSelectorsObject}`\r\n      )\r\n      const inputSelectorKeys = Object.keys(inputSelectorsObject)\r\n      const dependencies = inputSelectorKeys.map(\r\n        key => inputSelectorsObject[key]\r\n      )\r\n      const structuredSelector = selectorCreator(\r\n        dependencies,\r\n        (...inputSelectorResults: any[]) => {\r\n          return inputSelectorResults.reduce((composition, value, index) => {\r\n            composition[inputSelectorKeys[index]] = value\r\n            return composition\r\n          }, {})\r\n        }\r\n      )\r\n      return structuredSelector\r\n    },\r\n    { withTypes: () => createStructuredSelector }\r\n  ) as StructuredSelectorCreator\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}